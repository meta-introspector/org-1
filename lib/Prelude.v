(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Definition op_ltlt {A B C : Set}
  (f_value : A -> B) (g_value : C -> A) (x_value : C) : B :=
  f_value (g_value x_value).

Definition identity {A : Set} (x_value : A) : A := x_value.

Definition repeat {A : Set} (n_value : int) (x_value : A) : list A :=
  let fix go (acc : list A) (function_parameter : int) : list A :=
    match
      (function_parameter,
        (let 'n_value := function_parameter in
        CoqOfOCaml.Stdlib.ge n_value 1)) with
    | (0, _) => acc
    | (n_value, true) => go (cons x_value acc) (Z.sub n_value 1)
    | (_, _) =>
      Stdlib.raise (Build_extensible "Invalid_argument" string "List.repeat")
    end in
  go nil n_value.

Definition hd_opt {A : Set} (function_parameter : list A) : option A :=
  match function_parameter with
  | cons h_value _ => Some h_value
  | _ => None
  end.

Fixpoint last_opt {A : Set} (function_parameter : list A) : option A :=
  match function_parameter with
  | [] => None
  | cons h_value [] => Some h_value
  | cons _ tl => last_opt tl
  end.

Fixpoint last {A : Set} (function_parameter : list A) : A :=
  match function_parameter with
  | [] => Stdlib.raise (Build_extensible "Not_found" unit tt)
  | cons h_value [] => h_value
  | cons _ tl => last tl
  end.

Definition remove {A : Set} (p_value : A -> bool) : list A -> list A :=
  Stdlib.List.filter (fun (x_value : A) => negb (p_value x_value)).

Definition join {A : Set} (separator : A) (l_value : list A) : list A :=
  let fix aux (acc : list A) (function_parameter : list A) : list A :=
    match function_parameter with
    | [] => acc
    | cons h_value [] => cons h_value acc
    | cons h_value t_value => cons h_value (cons separator (aux acc t_value))
    end in
  aux nil l_value.

Definition take {A : Set} (n_value : int) (l_value : list A) : list A :=
  let fix loop {B : Set}
    (n_value : int) (acc : list B) (function_parameter : list B) : list B :=
    match
      (function_parameter,
        match function_parameter with
        | cons h_value t_value => CoqOfOCaml.Stdlib.gt n_value 0
        | _ => false
        end) with
    | (cons h_value t_value, true) =>
      loop (Z.sub n_value 1) (cons h_value acc) t_value
    | (_, _) => List.rev acc
    end in
  loop n_value nil l_value.

Definition drop_last {A : Set} (n_value : int) (l_value : list A) : list A :=
  let len := CoqOfOCaml.List.length l_value in
  let fix loop {B : Set}
    (n_value : int) (acc : list B) (function_parameter : list B) : list B :=
    match
      (function_parameter,
        match function_parameter with
        | cons h_value t_value => CoqOfOCaml.Stdlib.gt n_value 0
        | _ => false
        end) with
    | (cons h_value t_value, true) =>
      loop (Z.sub n_value 1) (cons h_value acc) t_value
    | (_, _) => List.rev acc
    end in
  loop (Z.sub len n_value) nil l_value.

Definition split_n (n_value : int) (l_value : list int) : list int * list int :=
  if CoqOfOCaml.Stdlib.lt (CoqOfOCaml.List.length l_value) n_value then
    (l_value, [ 0 ])
  else
    let fix loop {A : Set}
      (n_value : int) (acc : list A) (function_parameter : list A)
      : list A * list int :=
      match
        (function_parameter,
          match function_parameter with
          | cons h_value t_value => CoqOfOCaml.Stdlib.gt n_value 0
          | _ => false
          end) with
      | (cons h_value t_value, true) =>
        loop (Z.sub n_value 1) (cons h_value acc) t_value
      | (_, _) => ((List.rev acc), l_value)
      end in
    loop n_value nil l_value.

Definition filter_map {A B : Set} (f_value : A -> option B) (l_value : list A)
  : list B :=
  let fix loop (dst : list B) (function_parameter : list A) : list B :=
    match function_parameter with
    | [] => List.rev dst
    | cons h_value t_value =>
      match f_value h_value with
      | None => loop dst t_value
      | Some x_value => loop (cons x_value dst) t_value
      end
    end in
  loop nil l_value.

Definition print_list (l_value : list string) : unit :=
  Stdlib.List.iter CoqOfOCaml.Stdlib.print_endline l_value.

Definition print_bool (function_parameter : bool) : unit :=
  match function_parameter with
  | true => CoqOfOCaml.Stdlib.print_string "true"
  | _ => CoqOfOCaml.Stdlib.print_string "false"
  end.

Module Array.
  Include Stdlib.Array.
  
  Definition findi {A : Set} (p_value : A -> bool) (xs : array A) : int :=
    let n_value := Stdlib.Array.length xs in
    let fix loop (i_value : int) : int :=
      if equiv_decb i_value n_value then
        Stdlib.raise (Build_extensible "Not_found" unit tt)
      else
        if p_value (Stdlib.Array.get xs i_value) then
          i_value
        else
          loop (Z.succ i_value) in
    loop 0.
End Array.

Definition starts_with (s_value : string) (check : string) : bool :=
  if
    CoqOfOCaml.Stdlib.ge (CoqOfOCaml.String.length s_value)
      (CoqOfOCaml.String.length check)
  then
    if
      equiv_decb
        (Stdlib.String.lowercase_ascii
          (Stdlib.String.sub s_value 0 (CoqOfOCaml.String.length check)))
        (Stdlib.String.lowercase_ascii check)
    then
      true
    else
      false
  else
    false.

Definition ends_with (s_value : string) (check : string) : bool :=
  let len := CoqOfOCaml.String.length s_value in
  let len_c := CoqOfOCaml.String.length check in
  if CoqOfOCaml.Stdlib.ge len len_c then
    if
      equiv_decb
        (Stdlib.String.lowercase_ascii
          (Stdlib.String.sub s_value (Z.sub len len_c) len_c))
        (Stdlib.String.lowercase_ascii check)
    then
      true
    else
      false
  else
    false.

Definition splitl (p_value : ascii -> bool) (str : string) : string * string :=
  let len := CoqOfOCaml.String.length str in
  let i_value := Stdlib.ref_value 0 in
  let '_ :=
    (* ❌ While loops not handled. *)
    while in
  ((Stdlib.String.sub str 0 (Stdlib.op_exclamation i_value)),
    (Stdlib.String.sub str (Stdlib.op_exclamation i_value)
      (Z.sub len (Stdlib.op_exclamation i_value)))).

Definition splitr (p_value : ascii -> bool) (str : string) : string * string :=
  let len := CoqOfOCaml.String.length str in
  let i_value := Stdlib.ref_value len in
  let '_ :=
    (* ❌ While loops not handled. *)
    while in
  ((Stdlib.String.sub str 0 (Stdlib.op_exclamation i_value)),
    (Stdlib.String.sub str (Stdlib.op_exclamation i_value)
      (Z.sub len (Stdlib.op_exclamation i_value)))).

Definition lchop (op_staroptstar : option int) : string -> string :=
  let n_value :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => 1
    end in
  fun (s_value : string) =>
    if CoqOfOCaml.Stdlib.lt n_value 0 then
      CoqOfOCaml.Stdlib.invalid_arg
        "String.lchop: number of characters to chop is negative"
    else
      let slen := CoqOfOCaml.String.length s_value in
      if CoqOfOCaml.Stdlib.le slen n_value then
        ""
      else
        Stdlib.String.sub s_value n_value (Z.sub slen n_value).

Definition is_uppercase (c_value : ascii) : bool :=
  andb (CoqOfOCaml.Stdlib.le "A" % char c_value)
    (CoqOfOCaml.Stdlib.le c_value "Z" % char).

Definition is_lowercase (c_value : ascii) : bool :=
  andb (CoqOfOCaml.Stdlib.le "a" % char c_value)
    (CoqOfOCaml.Stdlib.le c_value "z" % char).

Definition is_letter (c_value : ascii) : bool :=
  orb (is_uppercase c_value) (is_lowercase c_value).

Definition is_digit (function_parameter : ascii) : bool :=
  match function_parameter with
  |
    ("0" % char | "1" % char | "2" % char | "3" % char | "4" % char | "5" % char
    | "6" % char | "7" % char | "8" % char | "9" % char) => true
  | _ => false
  end.

Definition explode (s_value : string) : list ascii :=
  let fix exp (i_value : int) (l_value : list ascii) : list ascii :=
    if CoqOfOCaml.Stdlib.lt i_value 0 then
      l_value
    else
      exp (Z.sub i_value 1) (cons (Stdlib.String.get s_value i_value) l_value)
    in
  exp (Z.sub (CoqOfOCaml.String.length s_value) 1) nil.

Definition is_number (s_value : string) : bool :=
  let chars := explode s_value in
  Stdlib.List.for_all (fun (c_value : ascii) => is_digit c_value) chars.

Definition is_ordered (s_value : string) : bool :=
  let chars := explode s_value in
  andb
    (Stdlib.List.for_all (fun (c_value : ascii) => is_digit c_value)
      (drop_last 1 chars))
    (equiv_decb
      (Stdlib.String.get s_value (Z.sub (CoqOfOCaml.String.length s_value) 1))
      "." % char).

Definition get_ordered_number (s_value : string) : option int :=
  (* ❌ Try-with are not handled *)
  try_with
    (fun _ =>
      Stdlib.Scanf.sscanf s_value
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            (CamlinternalFormatBasics.String_literal ". "
              CamlinternalFormatBasics.End_of_format)) "%d. ")
        (fun (i_value : int) => Some i_value)) (fun _ => None).

Definition get_indent (line : string) : int :=
  let len := CoqOfOCaml.String.length line in
  (* ❌ Use a trivial matching for the `with` clause, like: *)
  typ_with_with_non_trivial_matching.

Definition result_default {A B : Set}
  (default : A) (function_parameter : sum A B) : A :=
  match function_parameter with
  | Stdlib.Ok result_value => result_value
  | Stdlib.Error _e => default
  end.

Definition lines (s_value : string) : list string :=
  Stdlib.String.split_on_char "010" % char s_value.

Definition clear_indents (s_value : string) : list string :=
  List.map Stdlib.String.trim (lines s_value).

Definition change_ext (ext : string) (file : string) : string :=
  if equiv_decb file "-" then
    file
  else
    String.append (Stdlib.Filename.chop_extension file) (String.append "." ext).
