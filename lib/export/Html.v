(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Definition macros {A : Set} : Stdlib.ref (list (A * string)) :=
  Stdlib.ref_value nil.

Definition options : Stdlib.ref (list (string * string)) :=
  Stdlib.ref_value nil.

Definition concatmap {A B : Set} (f_value : A -> list B) (l_value : list A)
  : list B := Stdlib.List.concat (List.map f_value l_value).

Definition list_element {A B : Set} : list A -> B := op_startypeminuserrorstar.

Definition handle_image_link {A B C D : Set} (url : A) (href : B) (label : C)
  : D := op_startypeminuserrorstar.

Fixpoint range {A B C : Set} : A -> B -> C := op_startypeminuserrorstar

with timestamp {A B C : Set} : A -> B -> C := op_startypeminuserrorstar.

Fixpoint map_inline {A B : Set} (l_value : list A) : list B :=
  concatmap inline l_value

with inline {A B : Set} (t_value : A) : list B := op_startypeminuserrorstar.

Definition get_int_option (name : string) : int :=
  (* ❌ Use a trivial matching for the `with` clause, like: *)
  typ_with_with_non_trivial_matching.

Definition construct_numbering {A B : Set}
  (config : A) (op_staroptstar : option bool) : int -> option (list int) -> B :=
  let toc :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => false
    end in
  fun (level : int) =>
    fun (numbering : option (list int)) =>
      let num_option := get_int_option "num" in
      if config.() then
        if CoqOfOCaml.Stdlib.le level num_option then
          match numbering with
          | Some l_value =>
            let numbering :=
              Stdlib.String.concat "."
                (List.map CoqOfOCaml.Stdlib.string_of_int l_value) in
            if toc then
              op_startypeminuserrorstar (String.append numbering ". ")
            else
              op_startypeminuserrorstar "span"
                [ ("class", "numbering"); ("style", "margin-right:6px") ]
                [ op_startypeminuserrorstar numbering ]
          | None => op_startypeminuserrorstar
          end
        else
          op_startypeminuserrorstar
      else
        op_startypeminuserrorstar.

Definition heading {A B C : Set} (config : A) : B -> C :=
  op_startypeminuserrorstar.

Fixpoint list_item {A B C : Set} (config : A) (x_value : B) : list C :=
  let content {D : Set} : D :=
    op_startypeminuserrorstar in
  in
  let items {D : Set} : D :=
    if equiv_decb (CoqOfOCaml.List.length x_value.()) 0 then
      op_startypeminuserrorstar
    else
      op_startypeminuserrorstar (list_element x_value.())
        (concatmap (list_item config) x_value.()) in
  match x_value.() with
  | None =>
    let block {D : Set} : D :=
      match x_value.() with
      | None =>
        op_startypeminuserrorstar
          [ ("checked", (CoqOfOCaml.Stdlib.string_of_bool checked)) ] "li"
          [ op_startypeminuserrorstar "p" (cons checked_html content); items ]
      | Some name =>
        op_startypeminuserrorstar
          [ ("checked", (CoqOfOCaml.Stdlib.string_of_bool checked)) ] "dl"
          [
            op_startypeminuserrorstar "dt" [ op_startypeminuserrorstar name ];
            op_startypeminuserrorstar "dd"
              (CoqOfOCaml.Stdlib.app content [ items ])
          ]
      end in
    [ block ]
  | Some number =>
    [
      op_startypeminuserrorstar
        [
          ("style", "list-style-type: none");
          ("checked", (CoqOfOCaml.Stdlib.string_of_bool checked))
        ] "li"
        [
          op_startypeminuserrorstar "p"
            (cons
              (op_startypeminuserrorstar
                (String.append
                  (CoqOfOCaml.Stdlib.string_of_int
                    number) ". "))
              (cons checked_html content));
          items
        ]
    ]
  end

with table {A B : Set} : A -> B := op_startypeminuserrorstar

with blocks {A B C : Set} (config : A) (l_value : list B) : list C :=
  List.map (block config) l_value

with block {A B C : Set} (config : A) (t_value : B) : C :=
  op_startypeminuserrorstar.

Definition toc {A B C : Set} (config : A) (content : B) : C :=
  let toc_option := get_int_option "toc" in
  let fix go {D E : Set} (content : D) : E :=
    op_startypeminuserrorstar in
  if CoqOfOCaml.Stdlib.gt toc_option 0 then
    let items {D : Set} : D :=
      go content in
    op_startypeminuserrorstar "div" [ ("id", "toc") ]
      [
        op_startypeminuserrorstar "h2"
          [ op_startypeminuserrorstar "Table of contents" ];
        items
      ]
  else
    op_startypeminuserrorstar.

Definition collect_macros {A : Set} (directives : list (string * A)) : unit :=
  let collected {B : Set} : list (B * string) :=
    List.map
      (fun (function_parameter : string * A) =>
        let '(_, df) := function_parameter in
        in
        (name, (Stdlib.String.trim definition)))
      (Stdlib.List.filter
        (fun (function_parameter : string * A) =>
          let '(name, _) := function_parameter in
          equiv_decb (Stdlib.String.uppercase_ascii name) "MACRO") directives)
    in
  Stdlib.op_coloneq macros collected.

Definition collect_options (directives : list (string * string)) : unit :=
  let collected :=
    (* ❌ Use a trivial matching for the `with` clause, like: *)
    typ_with_with_non_trivial_matching in
  Stdlib.op_coloneq options collected.

Definition directives_to_string {A B : Set} (directives : A) : B :=
  op_startypeminuserrorstar (op_startypeminuserrorstar directives).

Module HtmlExporter.
  Definition name : string := "html".
  
  Definition default_filename {A : Set} : A := op_startypeminuserrorstar "html".
  
  Definition export {A B C D : Set} (config : A) (doc : B) (output : C) : D :=
    let '_ := collect_macros doc.() in
    let '_ := collect_options doc.() in
    let blocks {E : Set} : list E :=
      blocks config doc.() in
    let blocks {E : Set} : list E :=
      if op_startypeminuserrorstar then
        cons (toc config doc.()) blocks
      else
        blocks in
    let body {E : Set} : list E :=
      [
        op_startypeminuserrorstar
          (String.append "<!-- directives: "
            (String.append (directives_to_string doc.())
              " -->" ++ String.String "010" ""));
        op_startypeminuserrorstar "div" [ ("id", "content") ] blocks
      ] in
    op_startypeminuserrorstar output body.
End HtmlExporter.
