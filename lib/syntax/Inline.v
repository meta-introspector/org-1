(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Module Macro.
  Module t.
    Record record : Set := Build {
      name : string;
      arguments : list string;
    }.
    Definition with_name name (r : record) :=
      Build name r.(arguments).
    Definition with_arguments arguments (r : record) :=
      Build r.(name) arguments.
  End t.
  Definition t := t.record.
End Macro.

Definition delims : list (ascii * (ascii * Variant.t)) :=
  [
    ("*" % char, ("*" % char, (Variant.Build "Bold" unit tt)));
    ("_" % char, ("_" % char, (Variant.Build "Underline" unit tt)));
    ("/" % char, ("/" % char, (Variant.Build "Italic" unit tt)));
    ("+" % char, ("+" % char, (Variant.Build "Strike_through" unit tt)));
    ("~" % char, ("~" % char, (Variant.Build "Code" unit tt)));
    ("=" % char, ("=" % char, (Variant.Build "Verbatim" unit tt)));
    ("[" % char, ("]" % char, (Variant.Build "Bracket" unit tt)));
    ("<" % char, (">" % char, (Variant.Build "Chev" unit tt)));
    ("{" % char, ("}" % char, (Variant.Build "Brace" unit tt)));
    ("(" % char, (")" % char, (Variant.Build "Paren" unit tt)))
  ].

Definition link_delims : list ascii :=
  [
    "[" % char;
    "]" % char;
    "<" % char;
    ">" % char;
    "{" % char;
    "}" % char;
    "(" % char;
    ")" % char;
    "*" % char;
    "$" % char
  ].

Definition prev : Stdlib.ref (option ascii) := Stdlib.ref_value None.

Definition emphasis_token {A : Set} (c_value : ascii) : A :=
  let blank_before_delimiter := Stdlib.ref_value false in
  op_startypeminuserrorstar op_startypeminuserrorstar
    (fun (x_value : B) =>
      if op_startypeminuserrorstar x_value then
        op_startypeminuserrorstar "space before token"
      else
        op_startypeminuserrorstar
          (op_startypeminuserrorstar
            (fun (function_parameter : ascii) =>
              match
                (function_parameter,
                  (let 'x_value := function_parameter in
                  equiv_decb x_value c_value)) with
              | (x_value, true) =>
                match Stdlib.op_exclamation prev with
                | Some x_value =>
                  let '_ :=
                    if equiv_decb x_value " " % char then
                      Stdlib.op_coloneq blank_before_delimiter true
                    else
                      tt in
                  false
                | None => false
                end
              | (("013" % char | "010" % char), _) => false
              | (x_value, _) =>
                let '_ := Stdlib.op_coloneq prev (Some x_value) in
                true
              end))
          (fun (s_value : B) =>
            let blank_before := Stdlib.op_exclamation blank_before_delimiter in
            let '_ := Stdlib.op_coloneq blank_before_delimiter false in
            if blank_before then
              op_startypeminuserrorstar "emphasis_token"
            else
              op_startypeminuserrorstar s_value)).

Definition between {A : Set} (c_value : ascii) : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar c_value c_value (emphasis_token c_value))
    (fun (s_value : B) =>
      op_startypeminuserrorstar op_startypeminuserrorstar
        (fun (function_parameter : option ascii) =>
          match function_parameter with
          | None => op_startypeminuserrorstar s_value
          | Some c_value =>
            match c_value with
            |
              ("010" % char | "013" % char | " " % char | "009" % char |
              "." % char | "," % char | "!" % char | "?" % char | """" % char |
              "'" % char | ")" % char | "-" % char | ":" % char | ";" % char |
              "[" % char | "}" % char) => op_startypeminuserrorstar s_value
            | _ => op_startypeminuserrorstar "between"
            end
          end)).

Definition bold {A : Set} : A :=
  op_startypeminuserrorstar (between "*" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar) "Inline bold").

Definition underline {A : Set} : A :=
  op_startypeminuserrorstar (between "_" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar) "Inline underline").

Definition italic {A : Set} : A :=
  op_startypeminuserrorstar (between "/" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar) "Inline italic").

Definition strike_through {A : Set} : A :=
  op_startypeminuserrorstar (between "+" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar)
        "Inline strike_through").

Definition verbatim {A : Set} : A :=
  op_startypeminuserrorstar (between "=" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar) "Inline verbatim").

Definition code {A : Set} : A :=
  op_startypeminuserrorstar (between "~" % char)
    (fun (s_value : B) =>
      op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar) "Inline code").

Definition plain_delims : list ascii :=
  [
    "*" % char;
    "_" % char;
    "/" % char;
    "\" % char;
    "+" % char;
    "~" % char;
    "=" % char;
    "[" % char;
    "<" % char;
    "{" % char;
    "$" % char;
    "^" % char;
    "010" % char;
    "013" % char;
    "(" % char
  ].

Definition in_plain_delims (c_value : ascii) : bool :=
  Stdlib.List._exists (fun (d_value : ascii) => equiv_decb c_value d_value)
    plain_delims.

Definition whitespaces {A : Set} : A :=
  op_startypeminuserrorstar op_startypeminuserrorstar
    (fun (spaces : B) => op_startypeminuserrorstar op_startypeminuserrorstar).

Definition plain {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar false
      (fun (state : B) =>
        fun (c_value : ascii) =>
          if
            andb (op_startypeminuserrorstar c_value)
              (negb (in_plain_delims c_value))
          then
            Some true
          else
            None))
    (fun (function_parameter : B * C) =>
      let '(s_value, _state) := function_parameter in
      op_startypeminuserrorstar op_startypeminuserrorstar).

Definition emphasis {A : Set} : A :=
  op_startypeminuserrorstar op_startypeminuserrorstar
    (fun (function_parameter : ascii) =>
      match function_parameter with
      | "*" % char => bold
      | "_" % char => underline
      | "/" % char => italic
      | "+" % char => strike_through
      | _ => op_startypeminuserrorstar "Inline emphasis"
      end).

Definition hard_breakline {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar (op_startypeminuserrorstar "\")
      op_startypeminuserrorstar)
    (fun (function_parameter : B) =>
      let '_ := function_parameter in
      op_startypeminuserrorstar op_startypeminuserrorstar).

Definition breakline {A : Set} : A :=
  op_startypeminuserrorstar op_startypeminuserrorstar
    (fun (function_parameter : B) =>
      let '_ := function_parameter in
      op_startypeminuserrorstar op_startypeminuserrorstar).

Definition radio_target {A : Set} : A :=
  op_startypeminuserrorstar "<<<" ">>>"
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (fun (function_parameter : ascii) =>
          match function_parameter with
          | (">" % char | "013" % char | "010" % char) => false
          | _ => true
          end))
      (fun (s_value : B) => op_startypeminuserrorstar op_startypeminuserrorstar)).

Definition target {A : Set} : A :=
  op_startypeminuserrorstar "<<" ">>"
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (fun (function_parameter : ascii) =>
          match function_parameter with
          | (">" % char | "013" % char | "010" % char) => false
          | _ => true
          end))
      (fun (s_value : B) => op_startypeminuserrorstar op_startypeminuserrorstar)).

Definition entity {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar (op_startypeminuserrorstar "\" % char)
      (op_startypeminuserrorstar op_startypeminuserrorstar))
    (fun (s_value : B) =>
      (* âŒ Use a trivial matching for the `with` clause, like: *)
      typ_with_with_non_trivial_matching).



Definition nested_emphasis {A : Set} : A :=
  let fix aux_nested_emphasis {B C : Set} : B -> C :=
    op_startypeminuserrorstar in
  op_startypeminuserrorstar emphasis
    (fun (e_value : B) =>
      op_startypeminuserrorstar (aux_nested_emphasis e_value)).

Definition statistics_cookie {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar "[" % char "]" % char
      (op_startypeminuserrorstar
        (fun (c_value : ascii) =>
          if
            orb (equiv_decb c_value "/" % char)
              (orb (equiv_decb c_value "%" % char)
                (op_startypeminuserrorstar c_value))
          then
            true
          else
            false)))
    (fun (s_value : string) =>
      (* âŒ Try-with are not handled *)
      try_with
        (fun _ =>
          let cookie {B : Set} : B :=
            Stdlib.Scanf.sscanf s_value
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.Char_literal "/" % char
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      CamlinternalFormatBasics.End_of_format))) "%d/%d")
              (fun (n_value : int) =>
                fun (n' : int) => op_startypeminuserrorstar) in
          op_startypeminuserrorstar op_startypeminuserrorstar)
        (fun _ =>
          (* âŒ Try-with are not handled *)
          try_with
            (fun _ =>
              let cookie {B : Set} : B :=
                Stdlib.Scanf.sscanf s_value
                  (CamlinternalFormatBasics.Format
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      (CamlinternalFormatBasics.Char_literal "%" % char
                        CamlinternalFormatBasics.End_of_format)) "%d%%")
                  (fun (n_value : int) => op_startypeminuserrorstar) in
              op_startypeminuserrorstar op_startypeminuserrorstar)
            (fun _ => op_startypeminuserrorstar "statistics_cookie"))).

Definition latex_fragment {A : Set} : A :=
  op_startypeminuserrorstar op_startypeminuserrorstar
    (fun (function_parameter : ascii) =>
      match function_parameter with
      | "$" % char =>
        op_startypeminuserrorstar op_startypeminuserrorstar
          (fun (c_value : ascii) =>
            if Stdlib.op_eqeq c_value "$" % char then
              op_startypeminuserrorstar
                (op_startypeminuserrorstar
                  (op_startypeminuserrorstar
                    (fun (x_value : ascii) => nequiv_decb x_value "$" % char))
                  (op_startypeminuserrorstar "$$"))
                (fun (s_value : B) => op_startypeminuserrorstar)
            else
              op_startypeminuserrorstar
                (op_startypeminuserrorstar
                  (op_startypeminuserrorstar
                    (fun (x_value : ascii) => nequiv_decb x_value "$" % char))
                  (op_startypeminuserrorstar "$" % char))
                (fun (s_value : B) => op_startypeminuserrorstar))
      | "\" % char =>
        op_startypeminuserrorstar op_startypeminuserrorstar
          (fun (function_parameter : ascii) =>
            match function_parameter with
            | "[" % char =>
              op_startypeminuserrorstar "\]"
                (fun (s_value : B) => op_startypeminuserrorstar)
            | "(" % char =>
              op_startypeminuserrorstar "\)"
                (fun (s_value : B) => op_startypeminuserrorstar)
            | _ => op_startypeminuserrorstar "latex fragment \"
            end)
      | _ => op_startypeminuserrorstar "latex fragment"
      end).

Definition macro {A : Set} : A :=
  op_startypeminuserrorstar
    (fun (name : B) =>
      fun (arguments : string) =>
        let arguments := Stdlib.String.split_on_char "," % char arguments in
        let arguments := List.map Stdlib.String.trim arguments in
        op_startypeminuserrorstar)
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar (op_startypeminuserrorstar "{{{")
        (op_startypeminuserrorstar
          (fun (c_value : ascii) => nequiv_decb c_value "(" % char)))
      (op_startypeminuserrorstar "(" % char))
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (fun (c_value : ascii) => nequiv_decb c_value ")" % char))
      (op_startypeminuserrorstar ")}}}")).

Definition date_time {A B C D : Set} (close_char : A) (active : B) (typ : C)
  : D := op_startypeminuserrorstar.

Definition general_timestamp {A : Set} : A :=
  let active_parser {B C : Set} (typ : B) : C :=
    date_time ">" % char true typ in
  let closed_parser {B C : Set} (typ : B) : C :=
    date_time "]" % char false typ in
  let parse {B C D : Set} (rest : B) (typ : C) : D :=
    op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (op_startypeminuserrorstar (op_startypeminuserrorstar rest)
          op_startypeminuserrorstar) op_startypeminuserrorstar)
      (fun (function_parameter : ascii) =>
        match function_parameter with
        | "<" % char => active_parser typ
        | "[" % char => closed_parser typ
        | _ => op_startypeminuserrorstar "general_timestamp"
        end) in
  op_startypeminuserrorstar
    (op_startypeminuserrorstar op_startypeminuserrorstar
      op_startypeminuserrorstar)
    (fun (function_parameter : ascii) =>
      match function_parameter with
      | "<" % char => active_parser "Date"
      | "[" % char => closed_parser "Date"
      | "S" % char => parse "CHEDULED:" "Scheduled"
      | "C" % char =>
        op_startypeminuserrorstar (op_startypeminuserrorstar 3)
          (fun (function_parameter : string) =>
            match function_parameter with
            | "LOS" => parse "ED:" "Closed"
            | "LOC" => parse "K:" "Clock"
            | _ => op_startypeminuserrorstar "general_timestamp C"
            end)
      | "D" % char => parse "EADLINE:" "Deadline"
      | _ => op_startypeminuserrorstar "general_timestamp"
      end).

Definition range {A : Set} : A :=
  let extract_time {B C : Set} (t_value : B) : C :=
    op_startypeminuserrorstar in
  op_startypeminuserrorstar
    (fun (clock : string) =>
      fun (t1 : B) =>
        fun (t2 : B) =>
          let t1 {B : Set} : B :=
            extract_time t1 in
          let t2 {B : Set} : B :=
            extract_time t2 in
          if equiv_decb clock "CLOCK:" then
            op_startypeminuserrorstar
          else
            op_startypeminuserrorstar)
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar op_startypeminuserrorstar
        (op_startypeminuserrorstar "CLOCK:")) op_startypeminuserrorstar)
    (op_startypeminuserrorstar general_timestamp
      (op_startypeminuserrorstar "--")) general_timestamp.

Definition timestamp {A : Set} : A :=
  op_startypeminuserrorstar range general_timestamp.

Definition link_inline {A : Set} : A :=
  let protocol_part {B : Set} : B :=
    op_startypeminuserrorstar
      (op_startypeminuserrorstar op_startypeminuserrorstar)
      (op_startypeminuserrorstar "://") in
  let link_part {B : Set} : B :=
    op_startypeminuserrorstar
      (fun (c_value : ascii) =>
        andb (op_startypeminuserrorstar c_value)
          (Stdlib.List.for_all (fun (c' : ascii) => nequiv_decb c_value c')
            link_delims)) in
  op_startypeminuserrorstar
    (fun (protocol : B) => fun (link : B) => op_startypeminuserrorstar)
    protocol_part link_part.

Definition concat_plains {A B : Set} (inlines : list A) : list B :=
  let l_value {C : Set} : list C :=
    Stdlib.List.fold_left
      (fun (acc : list C) => fun (inline : A) => op_startypeminuserrorstar) nil
      inlines in
  List.rev l_value.

Definition link {A : Set} : A :=
  let url_part {B : Set} : B :=
    op_startypeminuserrorstar
      (op_startypeminuserrorstar (op_startypeminuserrorstar "[[")
        (op_startypeminuserrorstar
          (fun (c_value : ascii) => nequiv_decb c_value "]" % char)))
      (op_startypeminuserrorstar (op_startypeminuserrorstar "][")) in
  let label_part {B : Set} : B :=
    op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (fun (c_value : ascii) => nequiv_decb c_value "]" % char))
      (op_startypeminuserrorstar "]]") in
  op_startypeminuserrorstar
    (fun (url : string) =>
      fun (label : string) =>
        let url {B : Set} : B :=
          if equiv_decb label "" then
            op_startypeminuserrorstar
          else
            if
              orb (equiv_decb (Stdlib.String.get url 0) "/" % char)
                (equiv_decb (Stdlib.String.get url 0) "." % char)
            then
              op_startypeminuserrorstar
            else
              (* âŒ Try-with are not handled *)
              try_with
                (fun _ =>
                  Stdlib.Scanf.sscanf url
                    (CamlinternalFormatBasics.Format
                      (CamlinternalFormatBasics.Scan_char_set None
                        "ÿÿÿÿÿÿÿûÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ"
                        (CamlinternalFormatBasics.Char_literal ":" % char
                          (CamlinternalFormatBasics.Scan_char_set None
                            "ÿûÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ"
                            CamlinternalFormatBasics.End_of_format)))
                      "%[^:]:%[^" ++ String.String "010" "]")
                    (fun (protocol : string) =>
                      fun (link : string) => op_startypeminuserrorstar))
                (fun _ => op_startypeminuserrorstar) in
        let parser {B : Set} : B :=
          op_startypeminuserrorstar
            (op_startypeminuserrorstar
              [
                nested_emphasis;
                latex_fragment;
                entity;
                code;
                subscript;
                superscript;
                plain;
                whitespaces
              ]) in
        let label {B : Set} : list B :=
          match op_startypeminuserrorstar parser label with
          | Stdlib.Ok result_value => concat_plains result_value
          | Stdlib.Error _e => [ op_startypeminuserrorstar ]
          end in
        op_startypeminuserrorstar) url_part label_part.

Definition export_snippet {A : Set} : A :=
  let name {B : Set} : B :=
    op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (fun (c_value : ascii) =>
          andb (op_startypeminuserrorstar c_value)
            (nequiv_decb c_value ":" % char)))
      (op_startypeminuserrorstar ":" % char) in
  let content {B : Set} : B :=
    op_startypeminuserrorstar
      (fun (function_parameter : ascii) =>
        match function_parameter with
        | "@" % char => false
        | ("013" % char | "010" % char) => false
        | _ => true
        end) in
  op_startypeminuserrorstar "@@" "@@"
    (op_startypeminuserrorstar
      (fun (name : B) => fun (content : B) => op_startypeminuserrorstar) name
      content).

Definition inline_source_code {A : Set} : A :=
  let language {B : Set} : B :=
    op_startypeminuserrorstar
      (fun (c_value : C) =>
        orb (op_startypeminuserrorstar c_value)
          (op_startypeminuserrorstar c_value)) in
  let options {B : Set} : B :=
    op_startypeminuserrorstar "[" % char "]" % char
      (op_startypeminuserrorstar
        (fun (c_value : ascii) =>
          andb (op_startypeminuserrorstar c_value)
            (nequiv_decb c_value "]" % char))) in
  let code {B : Set} : B :=
    op_startypeminuserrorstar "{" % char "}" % char
      (op_startypeminuserrorstar
        (fun (c_value : ascii) =>
          andb (op_startypeminuserrorstar c_value)
            (nequiv_decb c_value "}" % char))) in
  op_startypeminuserrorstar (op_startypeminuserrorstar "src_")
    (op_startypeminuserrorstar
      (fun (language : B) =>
        fun (options : B) => fun (code : B) => op_startypeminuserrorstar)
      language options code).

Definition id : Stdlib.ref int := Stdlib.ref_value 0.

Definition incr_id (id : Stdlib.ref int) : int :=
  let '_ := Stdlib.incr id in
  Stdlib.op_exclamation id.

Definition footnote_inline_definition {A B : Set} (op_staroptstar : option bool)
  : A -> list B :=
  let break :=
    match op_staroptstar with
    | Some op_starsthstar => op_starsthstar
    | None => false
    end in
  fun (definition : A) =>
    let choices {C : Set} : list C :=
      if break then
        [
          link;
          link_inline;
          radio_target;
          target;
          latex_fragment;
          nested_emphasis;
          entity;
          code;
          subscript;
          superscript;
          plain;
          whitespaces
        ]
      else
        [
          link;
          link_inline;
          radio_target;
          target;
          latex_fragment;
          nested_emphasis;
          entity;
          code;
          subscript;
          superscript;
          plain;
          whitespaces
        ] in
    let parser {C : Set} : C :=
      op_startypeminuserrorstar (op_startypeminuserrorstar choices) in
    match op_startypeminuserrorstar parser definition with
    | Stdlib.Ok result_value =>
      let result_value {C : Set} : list C :=
        concat_plains result_value in
      result_value
    | Stdlib.Error _e => [ op_startypeminuserrorstar ]
    end.

Definition latex_footnote {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar (op_startypeminuserrorstar "[fn::")
        (op_startypeminuserrorstar
          (fun (c_value : ascii) =>
            andb (nequiv_decb c_value "]" % char)
              (op_startypeminuserrorstar c_value))))
      (op_startypeminuserrorstar "]" % char))
    (fun (definition : B) => op_startypeminuserrorstar).

Definition footnote_reference {A : Set} : A :=
  op_startypeminuserrorstar latex_footnote
    (let name_part {B : Set} : B :=
      op_startypeminuserrorstar
        (op_startypeminuserrorstar (op_startypeminuserrorstar "[fn:")
          (op_startypeminuserrorstar
            (fun (c_value : ascii) =>
              andb (nequiv_decb c_value ":" % char)
                (andb (nequiv_decb c_value "]" % char)
                  (op_startypeminuserrorstar c_value)))))
        (op_startypeminuserrorstar (op_startypeminuserrorstar ":" % char)) in
    let definition_part {B : Set} : B :=
      op_startypeminuserrorstar
        (op_startypeminuserrorstar
          (fun (c_value : ascii) =>
            andb (nequiv_decb c_value "]" % char)
              (op_startypeminuserrorstar c_value)))
        (op_startypeminuserrorstar "]" % char) in
    op_startypeminuserrorstar
      (fun (name : string) =>
        fun (definition : string) =>
          let name :=
            if equiv_decb name "" then
              let '_ := Stdlib.incr id in
              String.append "_anon_"
                (CoqOfOCaml.Stdlib.string_of_int (Stdlib.op_exclamation id))
            else
              name in
          if equiv_decb definition "" then
            op_startypeminuserrorstar
          else
            op_startypeminuserrorstar) name_part definition_part).

Definition break_or_line {A : Set} : A :=
  let line {B : Set} : B :=
    op_startypeminuserrorstar op_startypeminuserrorstar
      (fun (s_value : C) => op_startypeminuserrorstar op_startypeminuserrorstar)
    in
  op_startypeminuserrorstar [ line; hard_breakline; breakline ].

Definition inline_choices {A : Set} : A :=
  op_startypeminuserrorstar
    [
      latex_fragment;
      hard_breakline;
      breakline;
      timestamp;
      entity;
      macro;
      statistics_cookie;
      footnote_reference;
      link;
      link_inline;
      export_snippet;
      radio_target;
      target;
      verbatim;
      code;
      nested_emphasis;
      subscript;
      superscript;
      plain
    ].

Definition parse {A : Set} : A :=
  op_startypeminuserrorstar (op_startypeminuserrorstar inline_choices)
    (fun (l_value : list B) => concat_plains l_value).

Definition string_of_url {A B : Set} : A -> B := op_startypeminuserrorstar.

Fixpoint ascii {A : Set} : A -> string := op_startypeminuserrorstar

with asciis {A : Set} (l_value : list A) : string :=
  Stdlib.String.concat "" (List.map ascii l_value).
