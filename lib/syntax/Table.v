(** File generated by coq-of-ocaml *)
Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Definition boundaries_spec {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar op_startypeminuserrorstar
      (op_startypeminuserrorstar "#+TBLFM:")) op_startypeminuserrorstar.

Definition separated_line {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (op_startypeminuserrorstar
          (op_startypeminuserrorstar op_startypeminuserrorstar
            (op_startypeminuserrorstar "|" % char))
          (op_startypeminuserrorstar
            (fun (c_value : ascii) =>
              orb (equiv_decb c_value "-" % char)
                (equiv_decb c_value "+" % char))))
        (op_startypeminuserrorstar "|" % char)) op_startypeminuserrorstar)
    (op_startypeminuserrorstar op_startypeminuserrorstar).

Definition split_into_columns (s_value : string) : list string :=
  List.map Stdlib.String.trim (Stdlib.String.split_on_char "|" % char s_value).

Definition row_line {A : Set} : A :=
  op_startypeminuserrorstar
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar
          (op_startypeminuserrorstar "|" % char))
        (op_startypeminuserrorstar op_startypeminuserrorstar))
      (op_startypeminuserrorstar op_startypeminuserrorstar))
    (fun (line : string) =>
      let line := Stdlib.String.trim line in
      let len := Z.sub (CoqOfOCaml.String.length line) 1 in
      if CoqOfOCaml.Stdlib.ge len 0 then
        if nequiv_decb (Stdlib.String.get line len) "|" % char then
          op_startypeminuserrorstar "raw_line"
        else
          let s_value := Stdlib.String.sub line 0 len in
          op_startypeminuserrorstar (split_into_columns s_value)
      else
        op_startypeminuserrorstar "raw_line").

Definition group {A : Set} : A :=
  let p_value {B C : Set} (rows : Stdlib.ref (list (list B))) : C :=
    op_startypeminuserrorstar
      (fun (p_value : D) =>
        op_startypeminuserrorstar (op_startypeminuserrorstar separated_line)
          (fun (function_parameter : option D) =>
            match function_parameter with
            | None =>
              op_startypeminuserrorstar row_line
                (fun (row : list D) =>
                  let row {D : Set} : list D :=
                    List.map
                      (fun (col : E) =>
                        op_startypeminuserrorstar [ op_startypeminuserrorstar ]
                          (op_startypeminuserrorstar op_startypeminuserrorstar
                            col)) row in
                  let '_ :=
                    Stdlib.op_coloneq rows
                      (cons row (Stdlib.op_exclamation rows)) in
                  op_startypeminuserrorstar p_value
                    (op_startypeminuserrorstar
                      (List.rev (Stdlib.op_exclamation rows))))
            | Some _ =>
              op_startypeminuserrorstar (List.rev (Stdlib.op_exclamation rows))
            end)) in
  op_startypeminuserrorstar p_value (Stdlib.ref_value nil) "table group".

Definition is_col_row {A B : Set} (row : A) : B := op_startypeminuserrorstar.

Definition build_col_groups {A B : Set} (row : A) : B :=
  op_startypeminuserrorstar.

Definition extract_col_row {A B : Set}
  (header : A) (t_value : Stdlib.List.t (list (Stdlib.List.t B)))
  : A * Stdlib.List.t (list (Stdlib.List.t B)) * Stdlib.List.t B :=
  (* ❌ Try-with are not handled *)
  try_with
    (fun _ =>
      match
        ((Stdlib.List.hd (Stdlib.List.hd t_value)),
          (let 'row := Stdlib.List.hd (Stdlib.List.hd t_value) in
          is_col_row row)) with
      | (row, true) =>
        (header,
          (cons (Stdlib.List.tl (Stdlib.List.hd t_value))
            (Stdlib.List.tl t_value)), row)
      | (row, _) => (header, t_value, row)
      end) (fun _ => (header, t_value, nil)).

Definition parse {A : Set} : A :=
  let p_value {B C : Set} (groups : Stdlib.ref (list B)) : C :=
    op_startypeminuserrorstar
      (fun (p_value : D) =>
        op_startypeminuserrorstar group
          (fun (g_value : B) =>
            let '_ :=
              Stdlib.op_coloneq groups
                (cons g_value (Stdlib.op_exclamation groups)) in
            op_startypeminuserrorstar p_value
              (op_startypeminuserrorstar
                (List.rev (Stdlib.op_exclamation groups))))) in
  op_startypeminuserrorstar
    (op_startypeminuserrorstar
      (op_startypeminuserrorstar
        (op_startypeminuserrorstar op_startypeminuserrorstar)
        (op_startypeminuserrorstar p_value (Stdlib.ref_value nil) "table"))
      (op_startypeminuserrorstar boundaries_spec))
    (fun (groups : list (list (Stdlib.List.t B))) =>
      in
      let col_groups {B : Set} : B :=
        build_col_groups col_groups in
      op_startypeminuserrorstar [ op_startypeminuserrorstar ]).
